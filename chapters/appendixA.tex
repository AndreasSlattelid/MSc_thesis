\chapter{Scripts}
%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour}, commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2
}

%\section{R-code to generate ESG-fixed rate path}
%\lstset{style=mystyle}
%\lstinputlisting[language = R, caption = {Estimating Term Structure}]{scripts/R/SBM_ESG_process.R}


%\section{R-code to generate Term Structure}
%\lstset{style=mystyle}
%\lstinputlisting[language = R, caption = {Estimating Term Structure}]{scripts/R/Nelson_Siegel.R}


%\newpage 

%\section{R-code to generate ESG-figures}
%\lstset{style=mystyle}
%\lstinputlisting[language = R, caption = {Generate ESG-risk score}]{scripts/R/criteria_plt.R}
\section{SOFR: Simulation of $\kappa_{t}^{3M-SOFR}$}
\begin{minted}{julia}
#statistics and distributions
using Random 
using Distributions
using Statistics

#data-wrangeling:
using DataFrames

#for numerical integration:
using QuadGK

#plotting histogram and LaTeX labels:
using Plots 
using LaTeXStrings

#---------------------------------------------------------------------
#time parameters
T0 = 1/12
T1 = 4/12
T2 = 7/12
T3 = 10/12
timepoints = [T0, T1, T2, T3]
n_steps = 10000

#We use that Vasicek is ATS, i.e P(t,T) = exp(-A(t,T)-B(t,T)r(t))

function r_Vasicek(alpha, m,sigma, r_t, time_interval, n_steps)
    """
    Args: 
        #Vasicek parameters:
        alpha (Float): speed of reversion 
        m (float): long term mean level 
        sigma (float): volatility 
        r_t (float): initial value of r = (r(u))
        
        #time:
        time_interval (vector): the time interval we model over e.g [0,3]
        n_steps (int): number of timesteps we partition over
    
    Returns: 
        it simulates the process: r = (r(u)), for u in [t_start, t_end]
    """

    #time partition: 
    t_start = time_interval[1]
    t_end = time_interval[2]
    dt = (t_end-t_start)/n_steps
    n_steps = length(collect(t_start:dt:t_end))

    #initializing r: 
    r = zeros(n_steps)
    r[1] = r_t

    #Standard normal rv's
    Z = rand(Normal(0,1), n_steps)

    for i in 2:n_steps
        r[i] = r[i-1] - alpha*(m-r[i-1])*dt + sigma*Z[i]*dt
    end

    return r
end

function B_ZCB(t,T)
    ans = -(1/alpha)*(exp(-alpha*(T-t))-1)
    return ans
end

function A_ZCB(t,T)
    integral, _ = quadgk(u -> B_ZCB(u,T)^(2), t,T)
    ans = m*B_ZCB(t,T) - m*(T-t) - (1/2)*sigma^(2)*integral 
    return ans
end

function P(t,T, r_t)
    ans = exp(-A_ZCB(t,T) -B_ZCB(t,T)*r_t)
    return ans
end

#--------------------------------------------------------------
#Calculating f^3M(t,S,T), again using ATS structure:
#f^3M(t,S,T) = 1/(T-S)*(exp(A(t,S,T) + B(t,S,T)r(t))-1)
function Sigma1(u,t,S,T)
    ans = exp(-alpha*(S-u)) - exp(-alpha*(T-u))
    return ans   
end

function Sigma2(u,t,S,T)
    ans = 1-exp(-alpha*(T-u))
    return ans
end

function B(t,S,T)
    ans = (1/alpha)*(exp(-alpha*(S-t))-exp(-alpha*(T-t)))
    return ans
end

function A(t,S,T)
    first_part = m*(T-S) - m*B(t,S,T)
    c1_2, _  = quadgk(u -> Sigma1(u, t, t, S)^(2), t,S) 
    c2_2, _  = quadgk(u -> Sigma2(u, t, S, T)^(2), S,T)

    ans = first_part + (1/2)*(sigma^2/alpha^2)*(c1_2 + c2_2)

    return ans
end


function f_3M(t,S,T, r_t)
    ans = (1/(T-S))*(exp(A(t,S,T) + B(t,S,T)*r_t) - 1)
    return ans
end 

#time t-value of kappa in SOFR-swap
function kappa_t(t, r_t)
    "
    Args: 
        t (float): a vector of time points i.e [0,T1]
        r_t (float): vector of realization of interest rate model
    Returns: 
        the fixed swap rate kappa_t_3M-SOFR
    "
    ZCB_prices = map(T -> P(t,T, r_t), timepoints[2:end])
    f_3M_rates = map((x, y) -> f_3M(t, x, y, r_t), timepoints[1:end-1], timepoints[2:end])
    above = sum(ZCB_prices.*f_3M_rates)
    below = sum(ZCB_prices) 
    ans = above/below
    return ans
end


function kappa_path(t, r)
    "
    Args: 
        t (float): vector of timepoints 
        r (float): vector of desired interest rate model
    Returns: 
        vector of (t,r_t)-valued kappa_t
    "
    ans = map((x, y) -> kappa_t(x, y), t, r)
    return ans
end

#Vasicek parameters: 
alpha = 0.25
m = 0.035
r_0 = 0.0425
sigma = 0.05

r_0 = 0.0425
t_start = 0 
t_end = T0

r = r_Vasicek(alpha, m, sigma, r_0, [t_start,t_end], n_steps)
dt = (t_end-t_start)/n_steps
t = collect(t_start:dt:t_end)

length(r)
n_sim = 10
M = zeros(length(r), n_sim)
R = zeros(length(r), n_sim)


Random.seed!(1234)
for i in 1:n_sim
    r = r_Vasicek(alpha, m, sigma, r_0, [t_start,t_end], n_steps)
    kappa = kappa_path(t,r)
    R[:, i] = r
    M[:, i] = kappa
end
M
R

plot(R, layout = (1,1), 
        legend = false,
        title = L"t \mapsto r(t),\alpha = 0.25, m = 0.035, \sigma = 0.05, r_{0} = 0.0425 "
        )
xticks!([0, 10_000/2 ,10_000], ["0", L"\frac{T_{0}}{2}", L"T_{0}"])


# plot each column of the matrix
plot(M, layout=(1,1), 
        legend = false, 
        title = L"t \mapsto \kappa_{t}^{3M-SOFR},\alpha = 0.25, m = 0.035, \sigma = 0.05, r_{0} = 0.0425"
        )
xticks!([0, 10_000/2 ,10_000], ["0", L"\frac{T_{0}}{2}", L"T_{0}"])


\end{minted}

\newpage 

\section{SOFR: Hedging 3M-arithmetic SOFR}
\begin{minted}{julia}
using Random 
using Distributions
using Statistics

#for matrix operations and linear programming
using LinearAlgebra
using JuMP  #lp-problem setup
using HiGHS #lp-solver

#data-wrangeling:
using DataFrames

#for numerical integration:
using QuadGK

#plotting histogram and LaTeX labels:
using Plots 
using LaTeXStrings

#--------------------------------------------------------------------------#
#Vasicek parameters: 
alpha = 0.25
m = 0.035
r_t = 0.0425
sigma = 0.02

#time parameters
t = 0
S = 1/12
T1M = 2/12
T2M = 3/12
T = 4/12

function Sigma1(u,t,S,T)
    ans = exp(-alpha*(S-u)) - exp(-alpha*(T-u))
    return ans   
end


function Sigma2(u,t,S,T)
    ans = 1-exp(-alpha*(T-u))
    return ans
end


function int_r_start_stop(low,up, t)
    "
    Args: 
        low: (float), lower integration limit
        up: (float), upper integtation limit
    Returns: 
        the integral: int_low_up r(u)du
    "
    if t > low
        return "Please chose t <=low"
    end

    #Sigma1 is N(0, int_t_low c1_2 du), Sigma2 is N(0, int_low_up c2_2 du)
    c1_2, _  = quadgk(u -> Sigma1(u, t, low,up)^(2), t,low) 
    c2_2, _  = quadgk(u -> Sigma2(u, t, low,up)^(2), low,up)
    
    c1 = sqrt(c1_2)
    c2 = sqrt(c2_2)
    Z = rand(Normal(0,1))
    ans = ((r_t-m)/alpha)*(exp(-alpha*(low-t))-exp(-alpha*(up-t))) + m*(up-low) + sigma/alpha*(c1*Z + c2*Z)
    return ans
end


function integrand_E_Q_r(u, r_t, t)
    ans = exp(-alpha*(u-t))*r_t + m*(1-exp(-alpha*(u-t)))
    return ans
end

#int_S_T E_Q[r(u)|F_t]du:
integral_E_Q_r, _ = quadgk(u -> integrand_E_Q_r(u, r_t, t), S,T)

integral_E_Q_r
#--------------------------------------------------------------------------#
# Calculating a_hat_3M:

function B(t,S,T)
    ans = (1/alpha)*(exp(-alpha*(S-t))-exp(-alpha*(T-t)))
    return ans
end

function A(t,S,T)
    first_part = m*(T-S) - m*B(t,S,T)
    c1_2, _  = quadgk(u -> Sigma1(u, t, t, S)^(2), t,S) 
    c2_2, _  = quadgk(u -> Sigma2(u, t, S, T)^(2), S,T)

    ans = first_part + (1/2)*(sigma^2/alpha^2)*(c1_2 + c2_2)

    return ans
end


function f_3M(t,S,T)
    ans = (1/(T-S))*(exp(A(t,S,T) + B(t,S,T)*r_t) - 1)
    return ans
end

f_3M(0,S,T)

a_hat = integral_E_Q_r/((T-S)*f_3M(0,S,T))

#-------------------------------------------------------------------------------------------#
# 3M-arithmetic vs (a,b,c) 1M-SOFR futures: 
integral1 , _ = quadgk(u -> integrand_E_Q_r(u, r_t, t), S,T1M)
integral2 , _ = quadgk(u -> integrand_E_Q_r(u, r_t, t), T1M,T2M)
integral3 , _ = quadgk(u -> integrand_E_Q_r(u, r_t, t), T2M,T)

f_1M_S_T1M = (1/(T1M-S))*integral1
f_1M_T1M_T2M = (1/(T2M-T1M))*integral2
f_1M_T2M_T = (1/(T-T2M))*integral3

#variable naming to be more consistent with MSc Thesis:
a = f_1M_S_T1M        #alpha, I use alpha in Vasicek, hence a: 
beta = f_1M_T1M_T2M   #beta
gamma = f_1M_T2M_T    #gamma

futures = [a,beta,gamma]

#E_Q[X^(3M_A)(S,T)|F_t] = q: 
q = (1/(T-S))*integral_E_Q_r 

#matrix of coeff: 
M = [a^(2)      a*beta  a*gamma;
     beta^(2)   a*beta  beta*gamma; 
     gamma^(2)  a*beta  beta*gamma] 
     
#vector of values: 
b = q.*[a;
        beta;
        gamma] 

#optimal weight of futures:
x_hat = inv(M)*b 
#-------------------------------------------------------------------------------------------#
# incase M is not invertible: 
# Define optimization problem
model = Model(HiGHS.Optimizer)
@variable(model, x[1:3])
@objective(model, Min, sum(x))
@constraint(model, M * x .== b)
@constraint(model, -1 .<= x .<= 1 )
abs.([1,2,-3])
# Solve optimization problem
optimize!(model)
# optimal value
x_tilde = value.(x)

#-------------------------------------------------------------------------------------------#
# Simulations: 
n_sim = 10^(6)
#constants: 
#int_S_T E_Q[r(u)|F_t]du:
integral_E_Q_r, _ = quadgk(u -> integrand_E_Q_r(u, r_t, t), S,T)

futures_weighted_M_inv = x_hat'futures
futures_weighted_BP = x_tilde'futures
futures_weighted_one_each = [1,1,1]'futures

X_3MA = zeros(n_sim)
for i in 1:n_sim
    #aritmetic interest rate relaization:
    X_3MA[i] = (1/(T-S))*(int_r_start_stop(S,T,t))
end

X_3MA
#elementwise substraction:
ER_1 = X_3MA .-(1/(T-S))*integral_E_Q_r
ER_2_M_inv = X_3MA .-futures_weighted_M_inv
ER_2_111 = X_3MA .-futures_weighted_one_each



#-----------------------------------------------------------
# plotting of histograms: 
mean_ER_1 = mean(ER_1)
mean_ER_1 = round(mean_ER_1, digits = 3)

sigma_ER_1 = std(ER_1) 
sigma_ER_1 = round(sigma_ER_1, digits = 2)

mean_ER_2_M_inv = mean(ER_2_M_inv)
mean_ER_2_M_inv = round(mean_ER_2_M_inv, digits = 3)

sigma_ER_2 = std(ER_2_M_inv)
sigma_ER_2 = round(sigma_ER_2_M_inv, digits = 2)

mean_ER_2_111 = mean(ER_2_111)
mean_ER_2_111 = round(mean_ER_2_111,digits =3)

sigma_ER_2_111 = std(ER_2_111)
sigma_ER_2_111 = round(sigma_ER_2_111, digits = 2)

#ER_1
histogram(ER_1, 
          color =:lightblue, 
          xlabel="Value", 
          ylabel="Frequency", 
          title = L"Histogram\; of\; ER_{1}(0), \; s_{ER_{1}}\approx 0.01,\;n_{sim} = 10^{6}", 
          labels = "ER_1(0)", 
          xticks = [-3*sigma_ER_1, -2*sigma_ER_1,-sigma_ER_1, mean_ER_1,  sigma_ER_1, 2*sigma_ER_1, 3*sigma_ER_1]
          )
vline!([mean_ER_1], lw = 5, labels = L"mean(ER_{1}(0))" )


#ER_2_M_inv:
histogram(ER_2_M_inv, 
          color =:lightblue, 
          xlabel="Value", 
          ylabel="Frequency", 
          title = L"Histogram\; of\; ER_{2}^{M_{inv}}(0), \; s_{ER_{2}^{M_{inv}}} \approx 0.01, \;n_{sim} = 10^{6}", 
          labels = L"ER_{2}^{M_{inv}}(0)", 
          xticks = [-3*sigma_ER_2, -2*sigma_ER_2,-sigma_ER_2, mean_ER_2_M_inv, sigma_ER_2, 2*sigma_ER_2, 3*sigma_ER_2]
          )
vline!([mean_ER_2_M_inv], lw = 5, labels = L"mean(ER_{2}^{M_{inv}}(0))")

#(1,1,1)-weight of futures:
histogram(ER_2_111, 
          color =:lightblue, 
          xlabel="Value", 
          ylabel="Frequency", 
          title = L"Histogram\; of\; ER_{2}^{(1,1,1)}(0), \; s_{ER_{2}^{(1,1,1)}} \approx 0.01, \;n_{sim} = 10^{6}", 
          labels = L"ER_{2}^{(1,1,1)}(0)", 
          xticks = [-12*sigma_ER_2_111,-10*sigma_ER_2_111, mean_ER_2_111, -7*sigma_ER_2_111, -5*sigma_ER_2_111])
vline!([mean_ER_2_one_each], lw = 5, labels =  L"mean(ER_{2}^{(1,1,1)}(0))")
\end{minted}

\newpage 

\section{Numerical Simulation For ESG swap rate}

\begin{minted}{julia}
using Random 
using Distributions
using Statistics

using LinearAlgebra
using Queryverse
using DataFrames

using Combinatorics
using Plots

function create_array(dims::Array{Tuple{Int,Int},1})
    "
    Args: 
        dims: (array(tuple)), vector of tuples, 
              where each element corresponds to matrix-dimension
    
    Returns:
        Array of matricies A = (M_1, â€¦, M_n)
        Each matrix can take on different dimensions, i.e:
        dimensions = [(m,n), (k,l), (r,q), ...] 
        The array will return matricies of zeros    
    "
    arr = Array{Array{Float64,2}}(undef, length(dims))

    for (i, dim) in enumerate(dims)
        arr[i] = zeros(dim...)
    end

    return(arr)
end

function all_perm(xs, n)
    " 
    Args: 
        xs: (Vector)
        n: (Int), desired length
    
    Returns:
        generates permutation of elements in vector xs of length n
        all_perm([0.0, 1.0], 2) = [0.0, 0.0],[1.0, 0.0], [0.0, 1.0], [1.0, 1.0]
        all_perm([0.0, 1.0], 3) = [0.0, 0.0, 0.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0], ...
    "
    return(vec(map(collect, Iterators.product(ntuple(_ -> xs, n)...))))
end 


function OU_CPP(z0::Float64, beta::Float64, sigma::Float64, lambda::Float64, mu::Float64, dt::Float64,T_end::Float64)
    " 
    Description:
        dZ(t) = -beta*Z(t)dt + sigma*dW(t) + dI(t)
        I(t): I(t) = sum_{i=1}^{N(t)}J_k, J_k ~ Exp(mu), 
        NB! Julia parametrize with 1/mu

    Args:    
        z0: (float) inital value of the process Z(t)
        beta: (float), mean-retreving parameter
        sigma: (float), parameter of Brownian Motion
        lambda: (float), jump intensity of process, N(t)~ Pois(lambda*t) 
        dt: (float) stepsize 
        T_end: (float), for how long the simulation should go
     
    Returns: 
        X(t) = 100exp(-Z(t))
    "

    time = collect(0:dt:T_end) 
    n = length(time)

    #number of jumps from [0,T_end] on each dt: N(dt) ~ Pois(lambda*dt)
    N = rand(Poisson(lambda*dt),n) 

    #Brownian motion W~N(0,dt) on [0,dt]
    W = rand(Normal(0,1) ,n)

    #intialising Z(t)
    z = zeros(n)

    z[1] = z0

    #dZ(t) = -beta*Z(t)dt + sigma*dW(t) + dI(t)
    for i in 2:n 
        dI = sum(rand(Exponential(mu), N[i])) - sum(rand(Exponential(mu), N[i-1]))
        z[i] = z[i-1] - beta*z[i-1]*dt + sigma*W[i]*dt + dI
    end

    #X(t) = 100exp(-Z(t))
    x = 100*exp.(-z)
    df = DataFrame(time = time, score = x)
    return df
end

function simulation(n_sim, C_ESG, T_end, relevant_times)
    "
    Args:
        n_sim: (int) number of simulations 
        C_ESG: Vector(float) ESG-criteria at time T_{i}            
        relevant_times: (float) vector of relevant times, 
        [T1, T2, T3, ...], percentage of year.
    "

    "
    retruns:
        matrix of wheter or not criteria is meet
        each row in the matrix corresponds to a simulation, i.e
        m = [0,0,0; did not meet any criteria
             0,1,1; met criteria at T2 and T3
             ...  ] 
    "
    
    #store matrix of zeros, row = simulation number, col = agreed observation times
    m = zeros(n_sim, length(relevant_times))
    for i in 1:n_sim
        #df_tmp: general simulation 
        df_tmp = OU_CPP(-log(20/100), -0.05, 0.0,20.0, 1/150.0,1/360, T_end)
        #get the relevant timepoints as df:
        df_relevant = filter(row -> row.time in relevant_times, df_tmp)
        #get the score:
        relevant_score = df_relevant.score
    
        #check if X_{T_{i}} <= C^_{T_{i}}^{ESG} for T_{1}, ..., T_{n}
        ESG_criteria = relevant_score .<= C_ESG 
        ESG_criteria = Float64.(ESG_criteria)
        
        #store ESG_criteria:
        m[i, :] = ESG_criteria
    end

    return(m)
end

function D(i::Int, m::Matrix)
    " 
    Args:
        i: (Int), index in sequence 
        m: (Matrix), matrix containing simulations

    Returns: 
        D(i)-term in in E_{Q}[K_{i}^{ESG}(omega)|F_{t}]    
    "
    if i > size(m)[2]
        return println("You cannot evaluate D outside of agreed contract")
    end
    
    #adjusting for column dimensions in Boolean check:
    m_adj = m[:, 1:i]

    v = all_perm([0.0, 1.0], i)
    possible_patterns = mapreduce(permutedims, vcat, v)
    
    #use the row sum to determine how many errors/fails there are:
    success_sum = collect(0.0:Float64(i))
    
    #p is the indicator of successes for the trial:
    p = zeros(size(possible_patterns)[1], i+1)
    for k in 1:(i+1)
        p[:, k] = Bool[success_sum[k] == sum(possible_patterns[j, :]) for j=1:size(possible_patterns,1)]'
    end
    #turn p into Boolean object so that we can use findall:
    p = Bool.(p)

    #store row dimensions, so that we can initialize array later
    row_dims = zeros(Int, i+1)
    for i in 1:(i+1)
        row_dims[i] = size(possible_patterns[findall(p[:, i]), :])[1]
    end
    
    #initializing the needed dimensions
    dimensions = [(row_dims[k], i) for k in 1:(i+1)] 
    " 
    A: array of matricies, A=(M_1, ..., M_i)
    Let i = 3:
    M_1: matrix of patterns giving zero successes  [0,0,0] (1x3)
    M_2: matrix of patterns giving one succeses    [0,0,1;
                                                    0,1,0; 
                                                    1,0,0] (3x3)
    M_3: matrix of patterns giving two succeses    [1,1,0;
                                                    1,0,1;
                                                    0,1,1] (3x3)                                                
    etc. 
    "
    A = create_array(dimensions) 

    for l in 1:(i+1)
        A[l] = possible_patterns[findall(p[:, l]), :]
    end

    " 
    E_fails: (vector) Expecation of all linear combinations where: 
    E_fails[1]: expectation of all linear combinations giving all fails (1 path)
    E_fails[2]: expectation of all linear combinaition giving fails, but 1 success (multiple paths)
    Let i=3: E_fails[1] = E[fff|F_t]
             E_fails[2] = E[ssf|F_t] + E[sfs|F_t] + E[fss|F_t]
    etc.
    "
    E_fails = zeros(i+1)

    for l in 1:(i+1)
        s = 0 
        for j in 1:size(A[l],1)
            s += mean(Bool[A[l][j, :] == m_adj[r, :] for r=1:size(m_adj,1)])
        end
        E_fails[l] = s
    end 
    
    #represents I_{2i}^{Even} = {2,...,2i}
    I_2_Even = collect(2.0:2.0:Float64(2*i))

    #represents vector of sum_{alpha in I_{2i}^{Even}}[i-alpha], 
    weight = i .- I_2_Even

    #all success, all success but one, all success but two, ... 
    E_success = reverse(E_fails)
    
    #=
    i*E_{Q}[\cap 1(A_{l})|F_t] + 
    sum_[alpha \in I_2_Even]sum_[j_1 != ... != j_I_alpha_Even]x
    E_{Q}[(\cap 1(A_{l}))^[[j_{1} != ... != j_I_alpha_Even]]|F_t] 
    =#

    ans = i*E_success[1] + sum(weight.*E_success[2:length(E_success)])

    return(ans)
end

relevant_times = [1.25, 2.25, 3.25, 4.25]

C_ESG = [17.6, 16.6, 15.6, 14.55]
m = simulation(10^(6), C_ESG, 4.25, relevant_times)


#----------------------------------------------------------------------------
#kappa_{t}^{ESG} and kappa_{t}: 
#Calculating kappa for the above example:

#constants:
d = 0.005 #discount
delta = 1.00  #equidistant distance between T_{i} and T_{i-1}
num_steps = 1:length(relevant_times) #number of relevant steps

#ZCB:
P_T0 = 0.995
P_T1 = 0.985
P_T2 = 0.975
P_T3 = 0.965
P_T4 = 0.955

#vector of ZCB
P = [P_T0, P_T1, P_T2, P_T3, P_T4] 

#ordinary fixed rate kappa form ZCB-swap
kappa_t_ZCB = (P[1]-P[length(P)])/(delta*sum(P[2:length(P)]))

#the ESG-Swap process:
function kappa_t_ESG(i)
    kappa_t_ZCB-d*D(i,m)
end

println("(t, kappa_t_ZCB, kappa_t_ESG, C_ESG, relevant_times)")
for i in 1:length(relevant_times)
    println((i, kappa_t_ZCB ,kappa_t_ESG(i), C_ESG, relevant_times))
end


#meet criteria often:  
C_ESG_2 = [18, 17, 16, 15]
m2 = simulation(10^(5), C_ESG_2, 4.25, relevant_times)

function kappa_t_ESG_2(i)
    kappa_t_ZCB-d*D(i,m2)
end

for i in 1:length(relevant_times)
    println((i, kappa_t_ZCB ,kappa_t_ESG_2(i), C_ESG_2, relevant_times))
end

#does not meet criteria: 
C_ESG_3 = 2.5

m3 = simulation(10^(5), C_ESG_3, 4.25, relevant_times)

function kappa_t_ESG_3(i)
    kappa_t_ZCB-d*D(i,m3)
end

for i in 1:length(relevant_times)
    println((i, kappa_t_ZCB ,kappa_t_ESG_3(i), C_ESG_3, relevant_times))
end


\end{minted}


%\lstset{style=mystyle}
%\lstinputlisting[language = julia, caption = {ESG-swap rate Simulation}]{ZCB_ESG_for_latex.jl}

%\jlinputlisting{ZCB_ESG_for_latex.jl}

%\lstinputlisting[language= Julia]{ZCB_ESG_for_latex.jl}


% displayed code
%\begin{jllisting}
%# some julia code
%println( "Here we go with Julia!")
%\end{jllisting}
